replace_mode_init :: fn () {
	active_editor = command_editor;
	buf :: get_active_buffer_and_editor();
	clear_buffer(buf);
	input_mode = InputMode.TEXT;

	is_replacing = false;

	// @Incomplete: use search.last_replacement

	assert(search.last_subject.len > 0);
	// @Cleanup: test
	target_buf, target_editor :: get_last_active_buffer_and_editor();
	set_cursor_position(target_buf, target_editor.cursor_index, search_results[0].start);
}

replace_mode_terminate :: fn () {
	std.str_delete(&replacement);
}

draw_replace_mode :: fn () {
	assert(active_editor == command_editor);
	assert(search.last_subject.len > 0);
	w, h :: get_command_editor_size();
	target_buf :: get_last_active_buffer_and_editor();

	if is_replacing {
		using draw;
		using Metric;

		line_height  :: metrics[auto LINE_HEIGHT ];
		text_padding :: metrics[auto TEXT_PADDING];

		set_shader_color();
		draw_shadow(0.f, 0.f, w, h, ShadowMode.BOTTOM);
		rect(0.f, 0.f, w, h, colors.command_background_color);

		title_x :: text_padding;
		title_y :: text_padding + (line_height * 0.5f - font.height * 0.5f);

		title :: tprint("Replacing '%' with '%'. Press [Enter] to replace, [A] to replace all.", search.last_subject, replacement);

		set_shader_font(&font);
		text(title_x, title_y, title, colors.command_title_color);
	} else {
		draw_command_editor(command_editor, 0.f, 0.f, w, h, tprint("Replace '%' in '%' with: ", search.last_subject, target_buf.name));
	}
	draw_last_status_message(0.f, h, w);
}

invoke_command_replace_mode :: fn (buf: *Buffer #maybe_unused, cmd: Command) bool {
	assert(active_editor == command_editor);
	assert(editors[active_editor].buffer_index == buf.index);

	using Command;
	switch cmd {
		INSERT_NEW_LINE {
			if is_replacing {
				target_buf, target_editor :: get_last_active_buffer_and_editor();
				batch_begin(target_buf);
				defer batch_end(target_buf);

				subject :: search.last_subject;
				assert(subject.len > 0);

				start :: get_cursor_position(target_buf, target_editor.cursor_index);
				end   :: start + subject.len;
				delete_range(target_buf, start, end);
				insert_string(target_buf, start, replacement);
			} else {
				buf :: get_active_buffer_and_editor();
				str :: peek_row(buf, 0);
				assert(replacement.len == 0);
				std.str_append(&replacement, str);

				is_replacing = true;
			}
		}

		default { return false; }
	}

	return true;
}

#private

is_replacing: bool;
replacement:  string;
