//
// Process
//

IoStream :: *u8;
Pid :: u32;

start_process :: fn (cmd: string_view, ctx: *?TContext) Error {
	// Implement this.
	cmd;
	ctx;
	return OK;
}

kill_process :: fn (pid: Pid, exit_code: s32) Error {
	pid;
	exit_code;
	return OK;
}

peek_pipe :: fn (stream: IoStream, error_on_close := false) (err: Error, available_bytes: u32, is_closed: bool) {
	stream;
	error_on_close;
	return OK, 0, true;
}

read_pipe :: fn (stream: IoStream, dest: *string, bytes_to_read: u32, error_on_close := false) (err: Error, is_closed: bool) {
	stream;
	dest;
	bytes_to_read;
	error_on_close;
	return OK, true;
}

write_pipe :: fn (stream: IoStream, msg: string_view, error_on_close := false) (err: Error, is_closed: bool) {
	stream;
	msg;
	error_on_close;
	return OK, true;
}

close_stream :: fn (handle: IoStream) {
	handle;
}

//
// MISC
//

get_fonts_directory :: fn () string {
	return std.str_new("/System/Library/Fonts");
}

new_filepath_from_url :: fn (url: string_view) (err: Error, filepath: string) {
	url;
	return OK, std.str_new();
}

//
// File change notifications
//

Watcher :: struct {
	using macos;

	stream: FSEventStreamRef;
}

watch_init :: fn () {
}

watch_terminate :: fn () {
}

WatchFor :: enum u32 #flags {
	FILE_CHANGES;
	DIRECTORY_CHANGES;
	MODIFICATIONS;
}

watch_changes :: fn (directory: string_view, flags: WatchFor) Error {
	using macos;
	using std;

	hash :: hash_combine(str_hash(directory), cast(u32) flags);

	path :: CFStringCreateWithCString(null, auto strtoc(directory), CFStringEncoding.UTF8);
	paths   :: CFArrayCreate(null, &path, 1, null);
	latency :: 3.0;

	w := tbl_lookup_ptr(&watched, hash);
	if w { return OK; }

	w = tbl_insert(&watched, hash);
	w.stream = FSEventStreamCreate(null, &change_callback, auto w, paths, kFSEventStreamEventIdSinceNow, latency, kFSEventStreamCreateFlagNone);
	run_loop :: CFRunLoopGetCurrent();
	run_loop_mode :: CFStringCreateWithCString(null, auto strtoc("kCFRunLoopDefaultMode"), CFStringEncoding.UTF8);
	defer CFRelease(run_loop_mode);

	FSEventStreamScheduleWithRunLoop(w.stream, run_loop, run_loop_mode);
	FSEventStreamStart(w.stream);

	return OK;
}

unwatch_changes :: fn (directory: string_view, flags: WatchFor) {
	directory;
	flags;
}

next_watcher_event :: fn (changed_directory: *string_view, change_kind: *WatchFor) bool {
	changed_directory;
	change_kind;
	return false;
}

get_file_last_write_time :: fn (filepath: string_view) (t: u64, err: Error) {
	filepath;
	return 0, OK;
}

#private
watched: std.Table(u32, Watcher);

change_callback :: fn (
    stream_ref: macos.ConstFSEventStreamRef,
    client_callback_info: *u8,
    num_events: usize,
    event_paths: *u8,
    event_flags: *macos.FSEventStreamEventFlags,
    event_ids: *macos.FSEventStreamEventId
) {
	stream_ref;
	client_callback_info;
	num_events;
	event_paths;
	event_flags;
	event_ids;
	print_log("Changes!!!");
};